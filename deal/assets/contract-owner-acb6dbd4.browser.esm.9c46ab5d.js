import{aB as B,aY as w,a7 as h,aO as P,aa as y,aF as k,aw as N,t as _,aZ as v,n as D,a_ as b,B as F,y as M,z as x,a$ as L,b0 as W}from"./index.a890a1de.js";import{h as m}from"./contract-appuri-5179a994.browser.esm.c8757e2e.js";import{C as U}from"./setErc20Allowance-204eaca5.browser.esm.52b9c268.js";import{g as A,f as S}from"./QueryParams-1a366d99.browser.esm.b689a7c0.js";import{a as O}from"./index.244ea9bd.js";class H{featureName=B.name;constructor(t,a){this.contractWrapper=t,this.metadata=a}async getDefaultRoyaltyInfo(){const[t,a]=await this.contractWrapper.read("getDefaultRoyaltyInfo",[]);return w.parseAsync({fee_recipient:t,seller_fee_basis_points:a})}async getTokenRoyaltyInfo(t){const[a,e]=await this.contractWrapper.read("getRoyaltyInfoForToken",[t]);return w.parseAsync({fee_recipient:a,seller_fee_basis_points:e})}setDefaultRoyaltyInfo=h(async t=>{const a=await this.metadata.get(),e=await this.metadata.parseInputMetadata({...a,...t}),r=await this.metadata._parseAndUploadMetadata(e);if(m("setContractURI",this.contractWrapper)){const o=new P(this.contractWrapper),n=[o.encode("setDefaultRoyaltyInfo",[e.fee_recipient,e.seller_fee_basis_points]),o.encode("setContractURI",[r])];return y.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[n],parse:l=>({receipt:l,data:()=>this.getDefaultRoyaltyInfo()})})}else throw new Error("Updating royalties requires implementing ContractMetadata in your contract to support marketplaces like OpenSea.")});setTokenRoyaltyInfo=h(async(t,a)=>{const e=w.parse(a);return y.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setRoyaltyInfoForToken",args:[t,e.fee_recipient,e.seller_fee_basis_points],parse:r=>({receipt:r,data:()=>this.getDefaultRoyaltyInfo()})})})}class K{constructor(t,a,e,r){this.featureName=e,this.nextTokenIdToMintFn=r,this.contractWrapper=t,this.storage=a}createDelayedRevealBatch=h(async(t,a,e,r)=>{if(!e)throw new Error("Password is required");const o=await this.storage.uploadBatch([U.parse(t)],{rewriteFileNames:{fileStartNumber:0}}),n=A(o),l=await this.nextTokenIdToMintFn(),c=await this.storage.uploadBatch(a.map(p=>U.parse(p)),{onProgress:r?.onProgress,rewriteFileNames:{fileStartNumber:l.toNumber()}}),s=A(c),i=await this.contractWrapper.read("getBaseURICount",[]),I=await this.hashDelayRevealPassword(i,e),R=await this.contractWrapper.read("encryptDecrypt",[_(s),I]);let g;if(await this.isLegacyContract())g=R;else{const p=await this.contractWrapper.getChainID(),u=v(["bytes","bytes","uint256"],[_(s),I,p]);g=D.encode(["bytes","bytes32"],[R,u])}return y.fromContractWrapper({contractWrapper:this.contractWrapper,method:"lazyMint",args:[c.length,n.endsWith("/")?n:`${n}/`,g],parse:p=>{const u=this.contractWrapper.parseLogs("TokensLazyMinted",p?.logs),T=u[0].args.startTokenId,E=u[0].args.endTokenId,C=[];for(let f=T;f.lte(E);f=f.add(1))C.push({id:f,receipt:p});return C}})});reveal=h(async(t,a)=>{if(!a)throw new Error("Password is required");const e=await this.hashDelayRevealPassword(t,a);try{const r=await this.contractWrapper.callStatic().reveal(t,e);if(!r.includes("://")||!r.endsWith("/"))throw new Error("invalid password")}catch{throw new Error("invalid password")}return y.fromContractWrapper({contractWrapper:this.contractWrapper,method:"reveal",args:[t,e]})});async getBatchesToReveal(){const t=await this.contractWrapper.read("getBaseURICount",[]);if(t.isZero())return[];const a=Array.from(Array(t.toNumber()).keys()),e=await Promise.all(a.map(s=>{if(m("getBatchIdAtIndex",this.contractWrapper))return this.contractWrapper.read("getBatchIdAtIndex",[s]);if(m("baseURIIndices",this.contractWrapper))return this.contractWrapper.read("baseURIIndices",[s]);throw new Error("Contract does not have getBatchIdAtIndex or baseURIIndices.")})),r=e.slice(0,e.length-1),o=await Promise.all(Array.from([0,...r]).map(s=>this.getNftMetadata(s.toString()))),n=await this.isLegacyContract(),c=(await Promise.all(Array.from([...e]).map(s=>n?this.getLegacyEncryptedData(s):this.contractWrapper.read("encryptedData",[s])))).map(s=>b(s)>0?n?s:D.decode(["bytes","bytes32"],s)[0]:s);return o.map((s,i)=>({batchId:F.from(i),batchUri:s.uri,placeholderMetadata:s})).filter((s,i)=>b(c[i])>0)}async hashDelayRevealPassword(t,a){const e=await this.contractWrapper.getChainID(),r=this.contractWrapper.address;return v(["string","uint256","uint256","address"],[a,e,t,r])}async getNftMetadata(t){return S(this.contractWrapper.address,this.contractWrapper.getProvider(),t,this.storage)}async isLegacyContract(){if(m("contractVersion",this.contractWrapper))try{return await this.contractWrapper.read("contractVersion",[])<=2}catch{return!1}return!1}async getLegacyEncryptedData(t){const a=(await M(()=>import("./IDelayedRevealDeprecated.e3b58415.js"),[])).default,r=await new x(this.contractWrapper.address,a,this.contractWrapper.getProvider()).functions.encryptedBaseURI(t);return r.length>0?r[0]:"0x"}}async function j(d,t,a,e,r){let o={};const n=e||W,c=(await L(d.getProvider(),t,n)).mul(a);return c.gt(0)&&(n===W?o={value:c}:n!==W&&r&&await O(d,n,c,a,0)),o}class G{featureName=k.name;constructor(t){this.contractWrapper=t}async get(){return this.contractWrapper.read("owner",[])}set=h(async t=>{const a=await N(t);return y.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setOwner",args:[a]})})}export{H as C,K as D,G as a,j as c};
