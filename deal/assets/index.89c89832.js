import{dT as C,cH as l,dU as f,dV as m,dW as u,dX as p,dY as I,dZ as E,d_ as _,d$ as q,e0 as D,e1 as P,e2 as v}from"./index.a890a1de.js";function j(a){return!!C(a.id)}function g(a){const e=C(a);if(!e)throw new Error(`No injected provider found for wallet: "${a}"`);return e}async function H(a,e,t){const n=g(a),c=(await n.request({method:"eth_requestAccounts"}))[0];if(!c)throw new Error("no accounts available");const i=l(c),r=await n.request({method:"eth_chainId"}).then(f);let o=e.chain&&e.chain.id===r?e.chain:m(r);return e.chain&&e.chain.id!==r&&(await T(n,e.chain),o=e.chain),y(n,i,o,t)}async function b(a,e,t){const n=g(a),c=(await n.request({method:"eth_accounts"}))[0];if(!c)throw new Error("no accounts available");const i=l(c),r=await n.request({method:"eth_chainId"}).then(f),o=t&&t.id===r?t:m(r);return y(n,i,o,e)}function w(a,e){const t={address:e,async sendTransaction(n){return{transactionHash:await a.request({method:"eth_sendTransaction",params:[{accessList:n.accessList,value:n.value?u(n.value):void 0,gas:n.gas?u(n.gas):void 0,from:this.address,to:n.to,data:n.data}]})}},async signMessage({message:n}){if(!t.address)throw new Error("Provider not setup");const s=(()=>typeof n=="string"?E(n):n.raw instanceof Uint8Array?_(n.raw):n.raw)();return await a.request({method:"personal_sign",params:[s,t.address]})},async signTypedData(n){if(!a||!t.address)throw new Error("Provider not setup");const s=q(n),{domain:c,message:i,primaryType:r}=s,o={EIP712Domain:D({domain:c}),...s.types};P({domain:c,message:i,primaryType:r,types:o});const d=v({domain:c??{},message:i,primaryType:r,types:o});return await a.request({method:"eth_signTypedData_v4",params:[t.address,d]})}};return t}async function y(a,e,t,n){const s=w(a,e);async function c(){a.removeListener("accountsChanged",r),a.removeListener("chainChanged",o),a.removeListener("disconnect",i)}function i(){c(),n.emit("disconnect",void 0)}function r(d){if(d[0]){const h=w(a,l(d[0]));n.emit("accountChanged",h),n.emit("accountsChanged",d)}else i()}function o(d){const h=m(f(d));n.emit("chainChanged",h)}return a.on&&(a.on("accountsChanged",r),a.on("chainChanged",o),a.on("disconnect",i)),[s,t,c,d=>T(a,d)]}async function T(a,e){const t=u(e.id);try{await a.request({method:"wallet_switchEthereumChain",params:[{chainId:t}]})}catch(n){if(n?.code===4902||n?.data?.originalError?.code===4902){const s=await p(e);await a.request({method:"wallet_addEthereumChain",params:[{chainId:t,chainName:s.name,nativeCurrency:s.nativeCurrency,rpcUrls:I(s),blockExplorerUrls:s.explorers?.map(c=>c.url)}]})}else throw n}}export{b as autoConnectInjectedWallet,H as connectInjectedWallet,g as getInjectedProvider,j as isInjectedWallet};
